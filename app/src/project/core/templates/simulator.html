<!DOCTYPE html>
<html>
<head>
  <title>Yuma Simulation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    .container {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      min-height: 100vh;
      padding: 20px;
      overflow: auto;
    }
    .input-section, .results-section {
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      transition: all 0.3s ease-in-out;
    }
    .input-section {
      flex: 1 1 30%;
      border-right: 1px solid #ccc;
    }
    .results-section {
      flex: 1 1 70%;
      overflow: auto;
    }
    .scrollable-div {
      max-height: calc(100vh - 150px);
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
      background-color: #f9f9f9;
    }
    fieldset {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 15px;
    }
    legend {
      font-weight: bold;
    }
    button {
      padding: 10px;
      font-size: 16px;
      background-color: #007BFF;
      color: #fff;
      border: none;
      cursor: pointer;
      margin-bottom: 10px;
    }
    button:hover {
      background-color: #0056b3;
    }

    /* Toggle arrow button */
    .toggle-btn {
      position: fixed;
      top: 50vh;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background-color: #007BFF;
      color: #fff;
      border: none;
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
      transition: left 0.3s ease-in-out;
    }

    /* Collapsed state: hide left panel */
    .collapsed .input-section {
      width: 0;
      overflow: hidden;
      padding: 0;
      border: none;
      flex: 0;
    }
    .collapsed .results-section {
      flex: 1 1 100%;
    }

    .chart-wrapper {
      margin: 0;
      text-align: left;
    }
    .container.collapsed .results-section .chart-wrapper {
      margin: 0 auto;
      text-align: center;
      display: block;
      max-width: 80%;
    }

    .case-container {
      margin-bottom: 40px;
      border-bottom: 1px solid #ccc;
      padding-bottom: 20px;
    }
  </style>
</head>
<body>

  <!-- Arrow button (its inner arrow is toggled via JS) -->
  <button class="toggle-btn" id="toggleBtn" onclick="togglePanel()">&#9664;</button>

  <div class="container" id="main-container">
    <!-- Input Section -->
    <div class="input-section">
      <h1>Yuma Simulation</h1>
      <form method="get">
        <fieldset>
          <legend>Select Cases and Yumas</legend>
          {{ selection_form.as_p }}
        </fieldset>
        <fieldset>
          <legend>Simulation Hyperparameters</legend>
          {{ hyper_form.as_p }}
        </fieldset>
        <fieldset>
          <legend>Yuma Parameters</legend>
          {{ yuma_form.as_p }}
        </fieldset>
        <button type="submit">Generate</button>
      </form>
    </div>

    <div class="results-section">
      {% if valid_forms %}
        <h2>Results</h2>
        <div class="scrollable-div">
          <div class="chart-wrapper" id="chartWrapper">
            <p>Loading charts for each selected case... <br/>
            </p>
          </div>
        </div>
      {% else %}
        <h2>Results</h2>
        <div class="scrollable-div">
          <p>No results generated yet. Select options and click "Generate".</p>
        </div>
      {% endif %}
    </div>
  </div>

  <script>
    function updateArrowPosition() {
      const container = document.getElementById("main-container");
      const toggleBtn = document.getElementById("toggleBtn");
      const containerRect = container.getBoundingClientRect();
      if (!container.classList.contains("collapsed")) {
        const newLeft = containerRect.left + 20 + ((containerRect.width - 40) * 0.3);
        toggleBtn.style.left = newLeft + "px";
      } else {
        const newLeft = containerRect.left + 20;
        toggleBtn.style.left = newLeft + "px";
      }
    }
    
    function togglePanel() {
      const container = document.getElementById("main-container");
      const toggleBtn = document.getElementById("toggleBtn");
      if (container.classList.contains("collapsed")) {
        container.classList.remove("collapsed");
        toggleBtn.innerHTML = "&#9664;";
      } else {
        container.classList.add("collapsed");
        toggleBtn.innerHTML = "&#9654;";
      }
      updateArrowPosition();
    }
    
    window.addEventListener("load", updateArrowPosition);
    window.addEventListener("resize", updateArrowPosition);

    // Convert valid_forms to a boolean
    const validFormsString = "{{ valid_forms|yesno:'true,false' }}";
    const validForms = (validFormsString === "true");

    // Parse as JSON
    const selectedCases = JSON.parse('{{ cases_json|escapejs }}');
    const yumasData = JSON.parse('{{ yumas_json|escapejs }}');

    function parseCaseNumber(caseName) {
      const match = caseName.match(/^Case\s+(\d+)/i);
      return match ? parseInt(match[1], 10) : 999999;
    }

    window.addEventListener("load", () => {
      if (validForms) {
        fetchAllCasesParallel();
      }
    });

    async function fetchAllCasesParallel() {
      const chartWrapper = document.getElementById("chartWrapper");
      chartWrapper.innerHTML = "";

      const sortedCases = [...selectedCases].sort((a, b) =>
        parseCaseNumber(a) - parseCaseNumber(b)
      );

      const simParams = yumasData.sim_params || {};
      const yumaParams = yumasData.yuma_params || {};

      const fetchPromises = sortedCases.map(caseName => {
        const url = new URL("{% url 'simulate_single_case' %}", window.location.origin);
        url.searchParams.set("case_name", caseName);
        url.searchParams.set("kappa", simParams.kappa);
        url.searchParams.set("bond_penalty", simParams.bond_penalty);
        url.searchParams.set("reset_bonds", simParams.reset_bonds);
        url.searchParams.set("liquid_alpha_consensus_mode", simParams.liquid_alpha_consensus_mode);
        url.searchParams.set("selected_yuma_key", yumasData.selected_yuma_key);
        url.searchParams.set("chosen_yuma", yumasData.chosen_yuma);
        url.searchParams.set("bond_moving_avg", yumaParams.bond_moving_avg);
        url.searchParams.set("liquid_alpha", yumaParams.liquid_alpha);
        url.searchParams.set("alpha_high", yumaParams.alpha_high);
        url.searchParams.set("alpha_low", yumaParams.alpha_low);
        url.searchParams.set("decay_rate", yumaParams.decay_rate);
        url.searchParams.set("capacity_alpha", yumaParams.capacity_alpha);
        url.searchParams.set("alpha_sigmoid_steepness", yumaParams.alpha_sigmoid_steepness);
        if (yumaParams.override_consensus_high !== null) {
          url.searchParams.set("override_consensus_high", yumaParams.override_consensus_high);
        }
        if (yumaParams.override_consensus_low !== null) {
          url.searchParams.set("override_consensus_low", yumaParams.override_consensus_low);
        }

        return fetch(url)
          .then(res => {
            if (!res.ok) throw new Error(`Status ${res.status}`);
            return res.text();
          })
          .then(html => {
            const safeId = caseName.replace(/\s+/g, "_");
            return {
              snippet: `
                <div class="case-container" id="container_for_${safeId}">
                  ${html}
                </div>
              `
            };
          })
          .catch(err => ({ snippet: `<div style="color:red;">Error fetching '${caseName}': ${err.message}</div>` }));
      });

      const results = await Promise.all(fetchPromises);

      for (const { snippet } of results) {
        chartWrapper.insertAdjacentHTML("beforeend", snippet);
      }
    }

  // AI GENERATED STUFF AHEAD - consider review and refactor :)
  // Utility: build a query string from a form element
  function serializeForm(form) {
    const params = new URLSearchParams();
    // All inputs, selects, checkboxes
    new FormData(form).forEach((value, key) => {
      // For checkboxes with same name, FormData correctly aggregates multiple entries
      params.append(key, value);
    });
    return params.toString();
  }

  // Apply query params to the form so that each control is set
  function populateFormFromURL(form) {
    const params = new URLSearchParams(window.location.search);
    for (const [key, value] of params.entries()) {
      const control = form.elements[key];
      if (!control) continue;
      if (control.type === 'checkbox') {
        control.checked = true;
      } else if (control.multiple) {
        // <select multiple>
        Array.from(control.options).forEach(opt => {
          opt.selected = params.getAll(key).includes(opt.value);
        });
      } else {
        control.value = value;
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const form = document.querySelector('form[method="get"]');

    // 1. On page load: populate form, then fetch charts if there's any query
    populateFormFromURL(form);
    if (window.location.search.length > 0) {
      // Avoid double-fetch: mark forms valid
      window.validFormsString = "true";
      fetchAllCasesParallel();
    }

    // 2. Intercept submit
    form.addEventListener('submit', e => {
      e.preventDefault();

      // 2a. Serialize form â†’ query string
      const qs = serializeForm(form);

      // 2b. Update URL (push a new history entry)
      const newURL = window.location.pathname + '?' + qs;
      history.pushState(null, '', newURL);

      // 2c. Trigger your AJAX loader
      fetchAllCasesParallel();
    });

    // 3. Handle back/forward navigation
    window.addEventListener('popstate', () => {
      // Repopulate form and reload the charts
      populateFormFromURL(form);
      fetchAllCasesParallel();
    });
  });

  // AI GENERATED STUFF ENDS HERE

  </script>

</body>
</html>
